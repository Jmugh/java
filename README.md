

### 反射为什么效率更低

**性能开销**:

- **`new` 关键字**: 当你使用`new`关键字来创建对象时，Java编译器在编译时会对对象的构造函数进行优化。这种方式是直接且高效的，因为它在编译时已经确定了构造函数和类的具体信息。
- **反射**: 使用反射创建对象时，Java在运行时需要解析类的元数据并调用构造函数。反射的操作需要动态查找类的定义、检查访问权限、调用构造函数等，这些都带来额外的性能开销。

**编译时优化**:

- **`new` 关键字**: 编译器可以进行各种优化，比如内联化、常量折叠等，这些优化有助于提高代码执行的效率。
- **反射**: 反射涉及到运行时的操作，因此编译器无法对这些操作进行优化。运行时的元数据解析和方法调用无法像编译时那样进行优化，从而影响性能。

**访问权限检查**:

- **`new` 关键字**: 编译时已经检查过构造函数的可访问性。
- **反射**: 在使用反射时，JVM在运行时需要进行额外的访问权限检查，这也会增加一些开销。





### ConcurrentHashMap jdk1.7

简而言之，ConcurrentHashMap在对象中保存了一个Segment数组，即将整个Hash表划分为多个分段；而每个Segment元素，即每个分段则类似于一个Hashtable；这样，在执行put操作时首先根据hash算法定位到元素属于哪个Segment，然后对该Segment加锁即可。因此，ConcurrentHashMap在多线程并发编程中可是实现多线程put操作。

![image-20240905142043997](images/image-20240905142043997.png)
