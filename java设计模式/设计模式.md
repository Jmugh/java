# 设计模式七大原则

单一职责原则





# UML类图



![image-20230604221248362](images/image-20230604221248362.png) 









# 单例模式

# 工厂模式

# 原型模式

# 建造者模式

## 需求

1. 需要建房子：这一过程为打桩、砌墙、封顶

2. 房子有各种各样的，比如普通房，高楼，别墅，各种房子的过程虽然一样，但是要求不要相同的.

3) 请编写程序，完成需求.



## 传统方式



### 类图

![image-20230711231801112](images/image-20230711231801112.png)





### 代码

AbstractHouse.java

```java
public abstract class AbstractHouse {
    public abstract void buildBasic();
    public abstract void buildWall();
    public abstract void roofed();
    public void build(){
        buildBasic();
        buildWall();
        roofed();
    }
}
```

CommonHouse.java

```java
public class CommonHouse extends AbstractHouse{
    @Override
    public void buildBasic() {
        System.out.println("给普通房子打地基");
    }
    @Override
    public void buildWall() {
        System.out.println("给普通房子砌墙");
    }
    @Override
    public void roofed() {
        System.out.println("给普通房子封顶");
    }
}
```



Client.java

```java
public class Client {
    public static void main(String[] args) {
        CommonHouse commonHouse = new CommonHouse();
        commonHouse.build();
    }
}
```



## 优缺点

1. 优点是比较好理解，简单易操作。

2) 设计的程序结构，过于简单，没有设计缓存层对象，程序的扩展和维护不好. 也就是说，这种设计方案，把产品(即：房子) 和 创建产品的过程(即：建房子流程) 封装在一起，耦合性增强了。

3) 解决方案：将产品和产品建造过程解耦 => 建造者模式.









## 建造者模式

### 基本介绍

**1)** 建造者模式（Builder Pattern）又叫生成器模式，是一种对象构建模式。它可以将复杂对象的建造过程抽象出来（抽象类别），使这个抽象过程的不同实现方

法可以构造出不同表现（属性）的对象。

**2)** **建造者模式** 是一步一步创建一个复杂的对象，它允许用户只通过指定复杂对象的类型和内容就可以构建它们，用户不需要知道内部的具体构建细节。



### 四个角色

建造者模式的四个角色

**1) Product**（产品角色）：一个具体的产品对象。

**2) Builder**（抽象建造者）：*创建一个Product对象的各个部件指定的 接口/抽象类。

**3) ConcreteBuilder**（具体建造者）： 实现接口，构建和装配各个部件。

**4) Director**（指挥者）： 构建一个使用Builder接口的对象。它主要是用于创建一个复杂的对象。它主要有两个作用，

​	一是：隔离了客户与对象的生产过程

​	二是：负责控制产品对象的生产过程

### 类图

![image-20230711232642455](images/image-20230711232642455.png)



### 代码



**House.java   产品**

```java
public class House {
    private String basic;//地基
    private String wall;
    private String roof;
    public String getBasic() {
        return basic;
    }
    public void setBasic(String basic) {
        this.basic = basic;
    }
    public String getWall() {
        return wall;
    }
    public void setWall(String wall) {
        this.wall = wall;
    }
    public String getRoof() {
        return roof;
    }
    public void setRoof(String roof) {
        this.roof = roof;
    }

    @Override
    public String toString() {
        return "House{" +
                "basic='" + basic + '\'' +
                ", wall='" + wall + '\'' +
                ", roof='" + roof + '\'' +
                '}';
    }
}
```

**HouseBuilder.java 抽象建造者**

```java
public abstract class HouseBuilder {
    House house = new House();
    public abstract void buildBasic();
    public abstract void buildWall();
    public abstract void roof();
    public House build(){
        return house;
    }
}
```



**CommonHouse.java  具体建造者（取个CommonHouseBuilder更好些）**

```java
public class CommonHouse extends HouseBuilder{
    @Override
    public void buildBasic() {
        this.house.setBasic("普通地基");
    }
    @Override
    public void buildWall() {
        this.house.setWall("普通砌墙");
    }
    @Override
    public void roof() {
        this.house.setRoof("普通封顶");
    }
}
```



**HouseDirector.java 指挥者，组合了建造者，传进来什么类型的建造者就建造什么样的房子**

```java
public class HouseDirector {
    HouseBuilder houseBuilder;
    public HouseDirector(HouseBuilder houseBuilder) {
        this.houseBuilder = houseBuilder;
    }
    public House constructHouse(){
        houseBuilder.buildBasic();
        houseBuilder.buildWall();
        houseBuilder.roof();
        return houseBuilder.house;
    }
}
```

Client.java

```java
public class Client {
    public static void main(String[] args) {
        HouseDirector houseDirector = new HouseDirector(new CommonHouse());
        House house = houseDirector.constructHouse();
        System.out.println(house);
    }
}
```





# 适配器模式

## 基本介绍

1) 适配器模式(Adapter Pattern)将某个类的接口转换成客户端期望的另一个接口表示，主的目的是兼容性，让原本因接口不匹配不能一起工作的两个类可以协同

工作。其别名为包装器(Wrapper)

2) 适配器模式属于结构型模式

3) 主要分为三类：**类适配器模式、对象适配器模式、接口适配器模式**

## 工作原理

1. 适配器模式：将一个类的接口转换成另一种接口.让原本接口不兼容的类可以兼容

2. 从用户的角度看不到被适配者，是解耦的

3) 用户调用适配器转化出来的目标接口方法，适配器再调用被适配者的相关接方法

4) 用户收到反馈结果，感觉只是和目标接口交互，如图

![image-20230712223640944](images/image-20230712223640944.png)





## 类适配器模式

基本介绍：Adapter类，通过继承src类，实现dst 类接口，完成src->dst的适配。

### 举例

以生活中充电器的例子来讲解适配器，充电器本身相当于Adapter，220V交流电。相当于src (即被适配者)，我们的目dst(即目标)是5V直流电

### 类图

![image-20230712224626653](images/image-20230712224626653.png)



### 代码

Voltage220v.java  被适配类

```java
public class Voltage220v {
    public int output220v(){
        System.out.println("这是220v电压");
        return 220;
    }
}
```

Voltage5v 目标类

```java
public interface Voltage5v {
    public int output5v();
}
```

VoltageAdapter 适配器类

```java
public class VoltageAdapter extends Voltage220v implements Voltage5v{
    @Override
    public int output5v() {
        int src = output220v();
        int dst = src/44;//变压器变压
        System.out.println("转成5v电压...");
        return dst;
    }
}
```

使用者

```java
public class Phone {
    public void charge(Voltage5v voltage5v){
        if(voltage5v.output5v() == 5){
            System.out.println("可以充电....");
        }
    }
}
```

缺点：继承了src  被适配器类，不好

## 对象适配器模式

<font color="red">**使用关联关系，替代继承**</font>

### 类图

![image-20230712230418999](images/image-20230712230418999.png)

### 代码

只需要改适配器类

```java
public class VoltageAdapter implements Voltage5v{
    private Voltage220v voltage220v;
    public VoltageAdapter(Voltage220v voltage220v) {
        this.voltage220v = voltage220v;
    }
    @Override
    public int output5v() {
        int src = voltage220v.output220v();
        int dst = src/44;//变压器变压
        System.out.println("转成5v电压...");
        return dst;
    }
}
```







## 接口适配器模式

### 原理理解

**类适配器模式中，适配器是一个类，被适配的是类，适配器继承了被适配的类**

**对象适配器中，适配器也是一个类，被适配的是对象，适配器聚合了被适配类型的对象**
<font color="red">**接口适配器中，适配器是抽象类，被适配的是接口，适配器类继承了被适配的这个接口。但是因为是接口，并不是所有的方法都需要适配怎么办？那就是适配器类是一个抽象类，使用时候可以通过匿名内部类方式。**</font>

### 类图

![image-20230712232859747](images/image-20230712232859747.png)



### 代码

被适配的接口

```java
public interface BeAdaptedInterface {
    public void m1();
    public void m2();
    public void m3();
    public void m4();
}
```



适配器类，抽象类，默认实现所有的方法。没有方法内容

```java
public class AbstractAdapter implements BeAdaptedInterface{
    @Override
    public void m1() {}
    @Override
    public void m2() {}
    @Override
    public void m3() {}
    @Override
    public void m4() {}
}
```

目标其实就是这个匿名类创建的对象，只想适配m1就只重写m1方法，

```java
public class Client {
    public static void main(String[] args) {
        AbstractAdapter adapter = new AbstractAdapter() {
            @Override
            public void m1() {
                System.out.println("适配方法...");
            }
        };
        adapter.m1();
    }
}
```



# 桥接模式

## 需求

<img src="images/image-20230713233613129.png" alt="image-20230713233613129" style="zoom:80%;" />

实现手机的多种款式和品牌。

## 传统方式



![image-20230713233725966](images/image-20230713233725966.png)

1. 扩展性问题(类爆炸)，如果我们再增加手机的样式(旋转式)，就需要增加各个品牌手机的类，同样如果我们增加一个手机品牌，也要在各个手机样式类下增加。

2) 违反了单一职责原则，当我们增加手机样式时，要同时增加所有品牌的手机，这样增加了代码维护成本.

3) 解决方案-使用桥接模式

## 桥接模式

### 基本介绍

1) 桥接模式(Bridge模式)是指：将**实现**与**抽象**放在两个不同的类层次中，使两个层次可以独立改变。

2) 是一种结构型设计模式

3) Bridge模式基于**类的最小设计原则**，通过使用封装、聚合及继承等行为让不同的类承担不同的职责。它的主要特点是把抽象(Abstraction)与行为实现

(Implementation)分离开来，从而可以保持各部分的独立性以及应对他们的功能扩展

### 类图

抽象版

![image-20230713234159474](images/image-20230713234159474.png)

1. Client类：桥接模式的调用者

2) 抽象类(Abstraction) :维护了 Implementor / 即它的实现类ConcreteImplementorA.., 二者是聚合关系, Abstraction 充当桥接类



具体版

![image-20230713234852707](images/image-20230713234852707.png)

### 代码

Brand.java 品牌 接口

```java
public interface Brand {
    public void call();
}
```

XiaoMi.java 具体品牌的手机

```java
public class XiaoMi implements Brand{
    @Override
    public void call() {
        System.out.println("XiaoMi手机call...");
    }
}
```

抽象手机，聚合了具体的品牌手机（品牌手机不是完整的手机，因为没有款式）

```java
public abstract class Phone {
    private Brand brand;
    public Phone(Brand brand) {
        this.brand = brand;
    }
    public void call(){
        this.brand.call();
    }
}
```

具体的完整的手机

```java
public class FoldPhone extends Phone{
    public FoldPhone(Brand brand) {
        super(brand);
    }

    @Override
    public void call() {
        super.call();
        System.out.println("这是折叠手机...");
    }
}
```

调用

```java
public class Client {
    public static void main(String[] args) {
        Phone foldPhone = new FoldPhone(new XiaoMi());
        foldPhone.call();
    }
}
```



**核心：Phone充当了桥的作用，调用Phone的call方法时候，实际调用的Brand类型手机的call方法。**

**实现方式 就是聚合。因为所有手机都有这样一个call方法，所以减少了类。只需要传入一个接口（父类）就行**

这样的方式，在添加新的手机品牌或者款式的时候都非常方便



# 装饰着模式

## 需求

星巴克咖啡订单项目（咖啡馆）：

1) 咖啡种类/单品咖啡：Espresso(意大利浓咖啡)、ShortBlack、LongBlack(美式咖啡)、Decaf(无因咖啡)

2) 调料：Milk、Soy(豆浆)、Chocolate

3) 要求在扩展**新的咖啡种类**时，具有良好的扩展性、改动方便、维护方便

4) 使用OO的来计算不同种类咖啡的费用客户可以点**单品咖啡**，也可以**单品**+**调料组合**。

## 类图

![image-20230714234109126](images/image-20230714234109126.png)



比如:装饰者模式下的订单：2份巧克力+一份牛奶的LongBlack

<img src="images/image-20230714234201694.png" alt="image-20230714234201694" style="zoom:50%;" />



1) Milk包含了LongBlack

2) 一份Chocolate包含了(Milk+LongBlack)

3) 一份Chocolate包含了(Chocolate+Milk+LongBlack)

4) 这样不管是什么形式的单品咖啡+调料组合，通过递归方式可以方便的组合和维护。

<font color="red">就像包装一样，真正的东西放最里边儿，外面套多种多样的包装，包装也收钱。包装和物品具有公共特性（价格，描述属性）</font>

## 代码

Drink总的类，是装饰器和被装饰者的公共父类

```java
public abstract class Drink {
    public String des;
    public float price;
    public void setDes(String des) {
        this.des = des;
    }
    public void setPrice(float price) {
        this.price = price;
    }
    public String getDes() {
        return des;
    }
    public float getPrice() {
        return price;
    }
    public abstract float cost();
}
```

Coffe 加个缓冲，物品里不会有物品

```java
public class Coffe extends Drink{
    @Override
    public float cost() {
        return super.getPrice();
    }
}
```

具体的物品 咖啡

```java
public class LongBlackCoffe extends Coffe{
    public LongBlackCoffe() {
        setDes("LongBlackCoffe");
        setPrice(20.0f);
    }
}
```

Decorator装饰器，里面有物品的。**注意这里的计算细节**

```java
public class Decorator extends Drink{
    public Drink drink;
    public Decorator(Drink drink) {
        this.drink = drink;
    }
    @Override
    public float cost() {
        return getPrice()+drink.cost();
    }
}
```

巧克力装饰

```java
public class ChocolateDecorator extends Decorator{
    public ChocolateDecorator(Drink drink) {
        super(drink);
        setDes(drink.getDes() + "加巧克力");
        setPrice(5.00f);
    }
}
```

牛奶装饰

```java
public class MilkDecorator extends Decorator{
    public MilkDecorator(Drink drink) {
        super(drink);
        setDes(drink.getDes() + "加牛奶");
        setPrice(2.0f);
    }
}
```



Client  套娃

```java
public class Client {
    public static void main(String[] args) {
        MilkDecorator milkChocolateLongBlackCoffe = new MilkDecorator(new ChocolateDecorator(new LongBlackCoffe()));
        System.out.println(milkChocolateLongBlackCoffe.getDes());
        System.out.println(milkChocolateLongBlackCoffe.cost());
    }
}
```















# 组合模式





# 外观模式



# 享元模式



# 代理模式



# 模板模式



# 命令模式



# 访问者模式





# 迭代器模式





# 观察者模式



# 中介者模式



# 备忘录模式



# 解释器模式



# 状态模式



# 策略模式



# 职责链模式
